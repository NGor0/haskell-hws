{-# LANGUAGE TypeApplications #-}
module Block2
    ( antisort
    , antiprimes
    , antiunion
    , antimerge
    , antiintercalate
    , antiantiintercalate
    , getNumberOrNot
    , getMailDomainOrNot
    , maybeMaybeMaybeMaybeMaybeMaybeMaybeOrNot
    , stupidTraverse
    ) where

import Data.Char ( isSpace )
import Data.List ( group, intersect, sort, union, nub, (\\) )
import Data.List.Split ( chunksOf )
import Data.Maybe ( fromMaybe, isJust )
import Text.Read ( readMaybe )
import Text.Regex.TDFA

import Block1 (f2_1)

-- return permutation of given list such that
-- it's not sorted in ascending or descending order 
antisort :: Ord a => [a] -> [a]
antisort xs = invert2 $ sort xs
  where      
    invert2 :: [a] -> [a]
    invert2 (x' : x'' : xs') = x'' : x' : xs'
    invert2 _ = error "Length of the given list must be greater than 2"

-- return first k not prime numbers
-- f2_1 check whether a number is prime
antiprimes :: Int -> [Integer]
antiprimes k = take k $ map toInteger $ filter (not . f2_1) [1..1000000000]

-- return elements that belong to only one list 
antiunion :: Eq a => [a] -> [a] -> [a]
antiunion xs ys = (xs `union` ys) \\ (xs `intersect` ys)

-- return the list of pairs, where the first element
-- of pair is the element's quantity in the list
-- and the second is the element itself
antimerge :: Eq a => [a] -> [(Int, a)]
antimerge xs = map (`count` xs) xsUnique
  where
    xsUnique = nub xs
    count x xs = (foldl (inc x) 0 xs, x)
    inc x acc y = (if x == y then succ else id) acc

-- return the list of pairs, where the first element
-- of pair is the number of consecutive repetitions
-- and the second is the element itself
antiintercalate :: Eq a => [a] -> [(Int, a)]
antiintercalate = map (\xs -> (length xs, head xs)) . group

-- return the list generated by its partition
antiantiintercalate :: [(Int, a)] -> [a]
antiantiintercalate = concatMap (uncurry replicate)

-- return parsed integer number packed in 'Maybe'
-- ('Nothing' for strings with incorrect characters),
-- ignoring space characters
getNumberOrNot :: String -> Maybe Integer
getNumberOrNot = readMaybe . filter (not . isSpace)

-- return domain name by string packed in
-- 'Maybe' if the string is correct email,
-- otherwise return 'Nothing'
getMailDomainOrNot :: String -> Maybe String
getMailDomainOrNot mail =
  let
    mailRegex = "[a-z0-9+._-]+[a-z0-9]@[a-z0-9-]+\\.[a-z][a-z]+"
  in
    if (mail =~ mailRegex) == ""
    then Nothing
    else pure $ tail $ dropWhile (not . (==) '@') mail

-- return the packed value if possible
-- otherwise return default second argument
maybeMaybeMaybeMaybeMaybeMaybeMaybeOrNot
  :: Maybe (Maybe (Maybe (Maybe (Maybe (Maybe a)))))
  -> a
  -> a
maybeMaybeMaybeMaybeMaybeMaybeMaybeOrNot mValue def =
  case mValue of
    Just (Just (Just (Just (Just (Just value))))) -> value
    _                                             -> def

-- do strange traverse with grouping in tuples of four
stupidTraverse :: [Maybe a] -> Maybe [(a, a, a, a)]
stupidTraverse xs =
  let
    xsJust = filter isJust xs

    toTuple :: [a] -> (a, a, a, a)
    toTuple (x1 : x2 : x3 : [x4]) = (x1, x2, x3, x4)
    toTuple _ = error "impossible"
  in
    if length xsJust `mod` 4 == 0
    then map toTuple . chunksOf 4 <$> sequence xsJust
    else Nothing

-- Done: 10/12